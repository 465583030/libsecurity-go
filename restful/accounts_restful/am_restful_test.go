package accounts_restful

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"testing"
	"time"

	"github.com/emicklei/go-restful"
	am "github.com/ibm-security-innovation/libsecurity-go/accounts"
	app "github.com/ibm-security-innovation/libsecurity-go/app/token"
	en "github.com/ibm-security-innovation/libsecurity-go/entity"
	// "github.com/ibm-security-innovation/libsecurity-go/password"
	logger "github.com/ibm-security-innovation/libsecurity-go/logger"
	cr "github.com/ibm-security-innovation/libsecurity-go/restful/common_restful"
	//	"github.com/ibm-security-innovation/libsecurity-go/restful/libsecurity"
	stc "github.com/ibm-security-innovation/libsecurity-go/defs"
	"github.com/ibm-security-innovation/libsecurity-go/restful/libsecurity_restful"
	ss "github.com/ibm-security-innovation/libsecurity-go/storage"
)

const (
	host     = "http://localhost"
	port     = ":8083"
	listener = host + port
	clientIP = "127.0.0.1"

	rootPwd   = "Im the root12#^" // generated by the generate_login utility
	userName1 = "User1"
	userName2 = "User2"

	secretCode     = "123456Aa@b"
	getMessageStr  = "get-data"
	emptyRes       = "{}"
	rootUserFactor = 1 // the root user can't be deleted
)

var (
	propertyName = stc.AmPropertyName
	uData, _     = json.Marshal(privilegePwd{secretCode, am.UserPermission})

	resourcePath string
	usersName    = []string{userName1, userName2}
	saltStr      = []byte("abcd")

	stRestful *libsecurity_restful.LibsecurityRestful
)

func init() {
	logger.Init(ioutil.Discard, ioutil.Discard, ioutil.Discard, ioutil.Discard)
	privateKeyFilePath := flag.String("rsa-private", "./dist/key.private", "RSA private key file path")
	secureKeyFilePath := flag.String("secure-key", "./dist/secureKey", "password to encrypt the secure storage")
	usersDataPath := flag.String("data-file", "./dist/data.txt", "Login information file")
	flag.Parse()

	ServicePath = cr.ServicePathPrefix + cr.Version + AmPrefix
	resourcePath = listener + ServicePath + UsersPath

	usersList := en.New()
	signKey, verifyKey := app.TokenSetUp(*privateKeyFilePath)
	loginKey := ss.GetSecureKey(*secureKeyFilePath)
	en.LoadInfo(*usersDataPath, loginKey, usersList)

	stRestful = libsecurity_restful.NewLibsecurityRestful()
	stRestful.SetData(usersList, loginKey, verifyKey, signKey, nil)

	rootCookieStr, _ := app.GenerateToken(stc.RootUserName, am.SuperUserPermission, clientIP, signKey)
	cr.SetCookie(rootCookieStr)

	for _, name := range usersName {
		stRestful.UsersList.AddUser(name)
	}

	go runServer()
	time.Sleep(100 * time.Millisecond)
}

func runServer() {
	wsContainer := restful.NewContainer()
	l := NewAmRestful()
	l.SetData(stRestful)
	l.RegisterFull(wsContainer)

	fmt.Printf("start listening on %v%v\n", host, port)
	server := &http.Server{Addr: port, Handler: wsContainer}
	log.Fatal(server.ListenAndServe())
}

func getExpectedData(sData string, okJ interface{}) (string, string, cr.Error, error) {
	found, exp, res, e, err := cr.GetExpectedData(sData, okJ)
	if found == true {
		return exp, res, e, err
	}

	switch okJ.(type) {
	case *am.AmUserInfo:
		var user am.AmUserInfo
		err = json.Unmarshal([]byte(sData), &user)
		res = fmt.Sprintf("%v-%v", user.Privilege, user.Pwd.Password)
		exp = fmt.Sprintf("%v-%v", okJ.(*am.AmUserInfo).Privilege, okJ.(*am.AmUserInfo).Pwd.Password)
	default:
		panic(fmt.Sprintf("Error unknown type: value: %v", okJ))
	}

	if err != nil {
		err = json.Unmarshal([]byte(sData), &e)
	}
	return exp, res, e, err
}

func exeCommandCheckRes(t *testing.T, method string, url string, expCode int, data string, okJ interface{}) string {
	code, sData, err := cr.HttpDataMethod(method, url, data)
	logger.Info.Printf("Method: %v, Url: %v, data: '%v', response code: %v, response data: '%v', error: %v\n",
		method, url, data, code, sData, err)
	exp, res, e, err := getExpectedData(sData, okJ)
	if code != expCode || res != exp || err != nil {
		t.Errorf("Test fail: run %v '%v' Expected status: %v, received %v, expected data: '%v' received: '%v', error: %v %v",
			method, url, expCode, code, exp, res, e, err)
		t.FailNow()
	}
	return res
}

func initAListOfUsers(t *testing.T, usersList []string) string {
	cookieStr, _ := app.GenerateToken(stc.RootUserName, am.SuperUserPermission, clientIP, stRestful.SignKey)
	cr.SetCookie(cookieStr)

	for _, name := range usersList {
		okUrlJ := cr.Url{Url: fmt.Sprintf("%v/%v", ServicePath, name)}
		url := resourcePath + "/" + name
		exeCommandCheckRes(t, cr.PUT_STR, url, http.StatusCreated, string(uData), okUrlJ)
		data, _ := stRestful.UsersList.GetPropertyAttachedToEntity(name, propertyName)
		exeCommandCheckRes(t, cr.GET_STR, url, http.StatusOK, "", data.(*am.AmUserInfo))
	}
	return string(uData)
}

func loginRoot(t *testing.T) {
	url := listener + ServicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleAuthenticateCommand]), UserPath)
	userLogin, _ := json.Marshal(pUserData{stc.RootUserName, rootPwd})
	exeCommandCheckRes(t, cr.PUT_STR, url, http.StatusOK, string(userLogin), cr.Match{Match: true})
}

// Verify that a root login with appropriate password successfully
// Verify that a root login with wrong password fails
// Verify that an unknown user can't login
// Verify that logout works ok
func TestLogin(t *testing.T) {
	loginRoot(t)
	url := listener + ServicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleAuthenticateCommand]), UserPath)
	userLogin, _ := json.Marshal(userData{stc.RootUserName, []byte(string(rootPwd + "a"))})
	exeCommandCheckRes(t, cr.PUT_STR, url, http.StatusMethodNotAllowed, string(userLogin), cr.Match{Match: false})
	url = listener + ServicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleAuthenticateCommand]), UserPath)
	userLogin, _ = json.Marshal(userData{stc.RootUserName + "1", []byte(string(rootPwd))})
	exeCommandCheckRes(t, cr.PUT_STR, url, http.StatusNotFound, string(userLogin), cr.Match{Match: false})
}

// Add AM property and get it
// Remove the propert and verify an error when try to get it
func Test_addRemoveAm(t *testing.T) {
	name := usersName[0]
	initAListOfUsers(t, usersName)

	okUrlJ := cr.Url{Url: fmt.Sprintf("%v/%v", ServicePath, name)}
	url := resourcePath + "/" + name
	exeCommandCheckRes(t, cr.PUT_STR, url, http.StatusCreated, string(uData), okUrlJ)
	data, _ := stRestful.UsersList.GetPropertyAttachedToEntity(name, propertyName)
	exeCommandCheckRes(t, cr.GET_STR, url, http.StatusOK, "", data.(*am.AmUserInfo))

	okUrlJ = cr.Url{Url: fmt.Sprintf("%v/%v", ServicePath, name)}
	url = resourcePath + "/" + name
	exeCommandCheckRes(t, cr.DELETE_STR, url, http.StatusNoContent, "", cr.StringMessage{Str: ""})

	exeCommandCheckRes(t, cr.GET_STR, url, http.StatusNotFound, "", cr.Error{Code: http.StatusNotFound})
}

// 1. As a root: Update the user privilege, verify the results
// 2. As a root: Update the root privilege, verify that it is not allowed
// 3. As the user: Update the user privilege, verify that it is not allowed
func TestUpdatePrivilege(t *testing.T) {
	userName := usersName[0]

	initAListOfUsers(t, usersName)
	url := listener + ServicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleUserPwdCommand]), UsersPath, userName, PrivilegePath)
	okUrlJ := cr.Url{Url: fmt.Sprintf("%v/%v", ServicePath, userName)}
	privilege, _ := json.Marshal(privilegePwd{Privilege: am.SuperUserPermission})
	exeCommandCheckRes(t, cr.PATCH_STR, url, http.StatusCreated, string(privilege), okUrlJ)

	url = listener + ServicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleUserPwdCommand]), UsersPath, stc.RootUserName, PrivilegePath)
	okUrlJ = cr.Url{Url: fmt.Sprintf("%v/%v", ServicePath, stc.RootUserName)}
	privilege, _ = json.Marshal(privilegePwd{Privilege: am.SuperUserPermission})
	exeCommandCheckRes(t, cr.PATCH_STR, url, http.StatusBadRequest, string(privilege), cr.Error{Code: http.StatusBadRequest})

	cookieStr, _ := app.GenerateToken(userName, am.UserPermission, clientIP, stRestful.SignKey)
	cr.SetCookie(cookieStr)
	exeCommandCheckRes(t, cr.PATCH_STR, url, http.StatusMethodNotAllowed, string(privilege), cr.Error{Code: http.StatusMethodNotAllowed})
}

// 1. As a user: Update the password, verify the results
// 2. As a root: Fail to update the password to the root
// 3. As a root: Update the password, verify that it is allowed
func TestUpdatePassword(t *testing.T) {
	userName := usersName[0]

	//	initAListOfUsers(t, usersName)
	cookieStr, _ := app.GenerateToken(userName, am.UserPermission, clientIP, stRestful.SignKey)
	cr.SetCookie(cookieStr)

	url := listener + ServicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleUserPwdCommand]), UsersPath, userName, PwdPath)
	okUrlJ := cr.Url{Url: fmt.Sprintf("%v/%v", ServicePath, userName)}
	pwd, _ := json.Marshal(cr.UpdateSecret{OldPassword: secretCode, NewPassword: secretCode + "1"})
	exeCommandCheckRes(t, cr.PATCH_STR, url, http.StatusCreated, string(pwd), okUrlJ)

	url = listener + ServicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleUserPwdCommand]), UsersPath, stc.RootUserName, PwdPath)
	okUrlJ = cr.Url{Url: fmt.Sprintf("%v/%v", ServicePath, stc.RootUserName)}
	pwd, _ = json.Marshal(cr.UpdateSecret{OldPassword: rootPwd, NewPassword: secretCode + "2"})
	exeCommandCheckRes(t, cr.PATCH_STR, url, http.StatusMethodNotAllowed, string(pwd), cr.Error{Code: http.StatusMethodNotAllowed})

	cookieStr, _ = app.GenerateToken(stc.RootUserName, am.SuperUserPermission, clientIP, stRestful.SignKey)
	cr.SetCookie(cookieStr)
	url = listener + ServicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleUserPwdCommand]), UsersPath, stc.RootUserName, PwdPath)
	okUrlJ = cr.Url{Url: fmt.Sprintf("%v/%v", ServicePath, stc.RootUserName)}
	pwd, _ = json.Marshal(cr.UpdateSecret{OldPassword: rootPwd, NewPassword: secretCode + "1"})
	exeCommandCheckRes(t, cr.PATCH_STR, url, http.StatusCreated, string(pwd), okUrlJ)
}
