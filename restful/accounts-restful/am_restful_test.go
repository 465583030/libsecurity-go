package accountsRestful

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"testing"
	"time"

	"github.com/emicklei/go-restful"
	am "github.com/ibm-security-innovation/libsecurity-go/accounts"
	app "github.com/ibm-security-innovation/libsecurity-go/app/token"
	defs "github.com/ibm-security-innovation/libsecurity-go/defs"
	en "github.com/ibm-security-innovation/libsecurity-go/entity"
	logger "github.com/ibm-security-innovation/libsecurity-go/logger"
	cr "github.com/ibm-security-innovation/libsecurity-go/restful/common-restful"
	"github.com/ibm-security-innovation/libsecurity-go/restful/libsecurity-restful"
	ss "github.com/ibm-security-innovation/libsecurity-go/storage"
)

const (
	host     = "http://localhost"
	port     = ":8083"
	listener = host + port
	clientIP = "127.0.0.1"

	rootPwd   = "Im the root12#^" // generated by the generate_login utility
	userName1 = "User1"
	userName2 = "User2"

	secretCode     = "123456Aa@b"
	getMessageStr  = "get-data"
	emptyRes       = "{}"
	rootUserFactor = 1 // the root user can't be deleted
)

var (
	propertyName = defs.AmPropertyName
	uData, _     = json.Marshal(privilegePwd{secretCode, am.UserPermission})

	resourcePath string
	usersName    = []string{userName1, userName2}
	saltStr      = []byte("abcd")

	stRestful *libsecurityRestful.LibsecurityRestful
)

func init() {
	logger.Init(ioutil.Discard, ioutil.Discard, ioutil.Discard, ioutil.Discard)
	privateKeyFilePath := flag.String("rsa-private", "./dist/key.private", "RSA private key file path")
	secureKeyFilePath := flag.String("secure-key", "./dist/secureKey", "password to encrypt the secure storage")
	usersDataPath := flag.String("data-file", "./dist/data.txt", "Login information file")
	flag.Parse()

	servicePath = cr.ServicePathPrefix + cr.Version + amPrefix
	resourcePath = listener + servicePath + usersPath

	usersList := en.New()
	signKey, verifyKey := app.SetupAToken(*privateKeyFilePath)
	loginKey := ss.GetSecureKey(*secureKeyFilePath)
	en.LoadInfo(*usersDataPath, loginKey, usersList)

	stRestful = libsecurityRestful.NewLibsecurityRestful()
	stRestful.SetData(usersList, loginKey, verifyKey, signKey, nil)

	rootCookieStr, _ := app.GenerateToken(defs.RootUserName, am.SuperUserPermission, false, clientIP, signKey)
	cr.TestSetCookie(rootCookieStr)

	for _, name := range usersName {
		stRestful.UsersList.AddUser(name)
	}

	go runServer()
	time.Sleep(100 * time.Millisecond)
}

func runServer() {
	wsContainer := restful.NewContainer()
	l := NewAmRestful()
	l.SetData(stRestful)
	l.RegisterFull(wsContainer)

	// for coverage purposes
	wsContainer1 := restful.NewContainer()
	l1 := NewAmRestful()
	l1.SetData(stRestful)
	l1.RegisterBasic(wsContainer1)


	fmt.Printf("start listening on %v%v\n", host, port)
	server := &http.Server{Addr: port, Handler: wsContainer}
	log.Fatal(server.ListenAndServe())
}

func getExpectedData(sData string, okJ interface{}) (string, string, cr.Error, error) {
	found, exp, res, e, err := cr.GetExpectedData(sData, okJ)
	if found == true {
		return exp, res, e, err
	}

	switch okJ.(type) {
	case *am.AmUserInfo:
		var user am.AmUserInfo
		err = json.Unmarshal([]byte(sData), &user)
		res = fmt.Sprintf("%v-%v", user.Privilege, user.Pwd.Password)
		exp = fmt.Sprintf("%v-%v", okJ.(*am.AmUserInfo).Privilege, okJ.(*am.AmUserInfo).Pwd.Password)
	default:
		panic(fmt.Sprintf("Error unknown type: value: %v", okJ))
	}

	if err != nil {
		err = json.Unmarshal([]byte(sData), &e)
	}
	return exp, res, e, err
}

func exeCommandCheckRes(t *testing.T, method string, url string, expCode int, data string, okJ interface{}) string {
	code, sData, err := cr.HTTPDataMethod(method, url, data)
	logger.Info.Printf("Method: %v, Url: %v, data: '%v', response code: %v, response data: '%v', error: %v\n",
		method, url, data, code, sData, err)
	exp, res, e, err := getExpectedData(sData, okJ)
	if code != expCode || res != exp || err != nil {
		t.Errorf("Test fail: run %v '%v' Expected status: %v, received %v, expected data: '%v' received: '%v', error: %v %v",
			method, url, expCode, code, exp, res, e, err)
		t.FailNow()
	}
	return res
}

func initAListOfUsers(t *testing.T, usersList []string) string {
	cookieStr, _ := app.GenerateToken(defs.RootUserName, am.SuperUserPermission, false, clientIP, stRestful.SignKey)
	cr.TestSetCookie(cookieStr)

	for _, name := range usersList {
		okURLJ := cr.URL{URL: fmt.Sprintf("%v/%v", servicePath, name)}
		url := resourcePath + "/" + name
		exeCommandCheckRes(t, cr.HTTPPutStr, url, http.StatusCreated, string(uData), okURLJ)
		data, _ := stRestful.UsersList.GetPropertyAttachedToEntity(name, propertyName)
		exeCommandCheckRes(t, cr.HTTPGetStr, url, http.StatusOK, "", data.(*am.AmUserInfo))
	}
	return string(uData)
}

func loginRoot(t *testing.T) {
	url := listener + servicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleAuthenticateCommand]), userPath)
	userLogin, _ := json.Marshal(pUserData{defs.RootUserName, rootPwd})
	exeCommandCheckRes(t, cr.HTTPPutStr, url, http.StatusOK, string(userLogin), cr.Match{Match: true})
}

// 1. Verify that a root login with appropriate password successfully
// 2. Verify that a root login with wrong password fails
// 3. Verify that an unknown user can't login
// 4. Verify that logout works ok
// 5. VErify that undefined user can't login
func TestLogin(t *testing.T) {
	loginRoot(t)
	url := listener + servicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleAuthenticateCommand]), userPath)
	userLogin, _ := json.Marshal(userData{defs.RootUserName, []byte(string(rootPwd + "a"))})
	exeCommandCheckRes(t, cr.HTTPPutStr, url, http.StatusMethodNotAllowed, string(userLogin), cr.Match{Match: false})
	url = listener + servicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleAuthenticateCommand]), userPath)
	userLogin, _ = json.Marshal(userData{defs.RootUserName + "1", []byte(string(rootPwd))})
	exeCommandCheckRes(t, cr.HTTPPutStr, url, http.StatusMethodNotAllowed, string(userLogin), cr.Match{Match: false})

	url = listener + servicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleAuthenticateCommand]), logoutPath)
	userLogin, _ = json.Marshal(pUserData{defs.RootUserName, rootPwd})
	exeCommandCheckRes(t, cr.HTTPDeleteStr, url, http.StatusNoContent, "", cr.StringMessage{Str: ""})

	url = listener + servicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleAuthenticateCommand]), userPath)
	userLogin, _ = json.Marshal(userData{"undef user", []byte(string(rootPwd))})
	exeCommandCheckRes(t, cr.HTTPPutStr, url, http.StatusMethodNotAllowed, string(userLogin), cr.Match{Match: false})
}

// 1. Verify that delete root user can't be done
// 2. Verify that delete undefined user can't be done
func Test_removeRootAndUndefUser(t *testing.T) {
	initAListOfUsers(t, usersName)

	url := resourcePath + "/" + defs.RootUserName
	data := cr.StringMessage{Str: cr.GetMessageStr}
	exeCommandCheckRes(t, cr.HTTPDeleteStr, url, http.StatusBadRequest, "", data)
	url = resourcePath + "/aa" + defs.RootUserName
	exeCommandCheckRes(t, cr.HTTPDeleteStr, url, http.StatusBadRequest, "", data)
}

// Add AM property and get it
// Remove the propert and verify an error when try to get it
func Test_addRemoveAm(t *testing.T) {
	name := usersName[0]
	initAListOfUsers(t, usersName)

	okURLJ := cr.URL{URL: fmt.Sprintf("%v/%v", servicePath, name)}
	url := resourcePath + "/" + name
	exeCommandCheckRes(t, cr.HTTPPutStr, url, http.StatusCreated, string(uData), okURLJ)
	data, _ := stRestful.UsersList.GetPropertyAttachedToEntity(name, propertyName)
	exeCommandCheckRes(t, cr.HTTPGetStr, url, http.StatusOK, "", data.(*am.AmUserInfo))

	okURLJ = cr.URL{URL: fmt.Sprintf("%v/%v", servicePath, name)}
	url = resourcePath + "/" + name
	exeCommandCheckRes(t, cr.HTTPDeleteStr, url, http.StatusNoContent, "", cr.StringMessage{Str: ""})

	exeCommandCheckRes(t, cr.HTTPGetStr, url, http.StatusNotFound, "", cr.Error{Code: http.StatusNotFound})
}

// 1. Generate token and verify it is OK
// 2. As a root: Update the user privilege, verify the results
// 3. As a root: Update the user privilege to undefined previlege, verify the results are StatusBadRequest
// 4. As a root: Update the root privilege, verify that it is not allowed
// 5. As the user: Update the user privilege, verify that it is not allowed
func TestUpdatePrivilege(t *testing.T) {
	userName := usersName[0]

	initAListOfUsers(t, usersName)
	
	url := listener + servicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleAuthenticateCommand]), verifyPath)
	data := cr.StringMessage{Str: cr.GetMessageStr}
	exeCommandCheckRes(t, cr.HTTPGetStr, url, http.StatusOK, "", data)

	url = listener + servicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleUserPwdCommand]), usersPath, userName, privilegePath)
	okURLJ := cr.URL{URL: fmt.Sprintf("%v/%v", servicePath, userName)}
	privilege, _ := json.Marshal(privilegePwd{Privilege: am.SuperUserPermission})
	exeCommandCheckRes(t, cr.HTTPPatchStr, url, http.StatusCreated, string(privilege), okURLJ)

	privilege, _ = json.Marshal(privilegePwd{Privilege: "no p"})
	exeCommandCheckRes(t, cr.HTTPPatchStr, url, http.StatusBadRequest, string(privilege), cr.Error{Code: http.StatusBadRequest})

	url = listener + servicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleUserPwdCommand]), usersPath, defs.RootUserName, privilegePath)
	okURLJ = cr.URL{URL: fmt.Sprintf("%v/%v", servicePath, defs.RootUserName)}
	privilege, _ = json.Marshal(privilegePwd{Privilege: am.SuperUserPermission})
	exeCommandCheckRes(t, cr.HTTPPatchStr, url, http.StatusBadRequest, string(privilege), cr.Error{Code: http.StatusBadRequest})

	cookieStr, _ := app.GenerateToken(userName, am.UserPermission, false, clientIP, stRestful.SignKey)
	cr.TestSetCookie(cookieStr)
	exeCommandCheckRes(t, cr.HTTPPatchStr, url, http.StatusMethodNotAllowed, string(privilege), cr.Error{Code: http.StatusMethodNotAllowed})
}

// 1. As a user: Update the password, verify the results
// 2. As a root: Fail to update the password to the root
// 3. As a root: Update the password, verify that it is allowed
func TestUpdatePassword(t *testing.T) {
	userName := usersName[0]

	//	initAListOfUsers(t, usersName)
	cookieStr, _ := app.GenerateToken(userName, am.UserPermission, false, clientIP, stRestful.SignKey)
	cr.TestSetCookie(cookieStr)

	url := listener + servicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleUserPwdCommand]), usersPath, userName, pwdPath)
	okURLJ := cr.URL{URL: fmt.Sprintf("%v/%v", servicePath, userName)}
	pwd, _ := json.Marshal(cr.UpdateSecret{OldPassword: secretCode, NewPassword: secretCode + "1"})
	exeCommandCheckRes(t, cr.HTTPPatchStr, url, http.StatusCreated, string(pwd), okURLJ)

	url = listener + servicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleUserPwdCommand]), usersPath, defs.RootUserName, pwdPath)
	okURLJ = cr.URL{URL: fmt.Sprintf("%v/%v", servicePath, defs.RootUserName)}
	pwd, _ = json.Marshal(cr.UpdateSecret{OldPassword: rootPwd, NewPassword: secretCode + "2"})
	exeCommandCheckRes(t, cr.HTTPPatchStr, url, http.StatusMethodNotAllowed, string(pwd), cr.Error{Code: http.StatusMethodNotAllowed})

	cookieStr, _ = app.GenerateToken(defs.RootUserName, am.SuperUserPermission, false, clientIP, stRestful.SignKey)
	cr.TestSetCookie(cookieStr)
	url = listener + servicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleUserPwdCommand]), usersPath, defs.RootUserName, pwdPath)
	okURLJ = cr.URL{URL: fmt.Sprintf("%v/%v", servicePath, defs.RootUserName)}
	pwd, _ = json.Marshal(cr.UpdateSecret{OldPassword: rootPwd, NewPassword: secretCode + "1"})
	exeCommandCheckRes(t, cr.HTTPPatchStr, url, http.StatusCreated, string(pwd), okURLJ)
}

// 1. As a root: 
//	1.1 Reset user password
//	1.2 Success get user account info
//	1.3 Fail to reset root user password
// 2. As a user: 
//	2.1 login with the new password
//	2.2 Fail to get account info
//	2.3 Change account password
//	2.4 Success get account info
func TestResetPassword(t *testing.T) {
	userName := usersName[0]
	updatedPwd := secretCode + "1"

	initAListOfUsers(t, usersName)
	// reset user password
	url := listener + servicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleUserCommand]), usersPath, userName)
	newPwd := exeCommandCheckRes(t, cr.HTTPPatchStr, url, http.StatusCreated, cr.GetMessageStr, cr.StringMessage{Str: cr.GetMessageStr})

	// fail to reset root user password
	url = listener + servicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleUserCommand]), usersPath, defs.RootUserName)
	exeCommandCheckRes(t, cr.HTTPPatchStr, url, http.StatusBadRequest, "", cr.Match{Match: false})

	// get user info
	url = resourcePath + "/" + userName
	data, _ := stRestful.UsersList.GetPropertyAttachedToEntity(userName, propertyName)
	exeCommandCheckRes(t, cr.HTTPGetStr, url, http.StatusOK, "", data.(*am.AmUserInfo))

	// login as user and fail to get user info
	d := data.(*am.AmUserInfo)
	cookieStr, _ := app.GenerateToken(userName, am.UserPermission, d.Pwd.TemporaryPwd, clientIP, stRestful.SignKey)
	cr.TestSetCookie(cookieStr)
	exeCommandCheckRes(t, cr.HTTPGetStr, url, http.StatusMethodNotAllowed, "", cr.Match{Match: false})

	var newPwdStr cr.Secret
	json.Unmarshal([]byte(newPwd), &newPwdStr)
	// update user account password
	url = listener + servicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleUserPwdCommand]), usersPath, userName, pwdPath)
	okURLJ := cr.URL{URL: fmt.Sprintf("%v/%v", servicePath, userName)}
	pwd, _ := json.Marshal(cr.UpdateSecret{OldPassword: newPwdStr.Secret, NewPassword: updatedPwd})
	exeCommandCheckRes(t, cr.HTTPPatchStr, url, http.StatusCreated, string(pwd), okURLJ)

	// login as root and get user info
	cookieStr, _ = app.GenerateToken(defs.RootUserName, am.SuperUserPermission, false, clientIP, stRestful.SignKey)
	cr.TestSetCookie(cookieStr)
	url = resourcePath + "/" + userName
	data, _ = stRestful.UsersList.GetPropertyAttachedToEntity(userName, propertyName)
	exeCommandCheckRes(t, cr.HTTPGetStr, url, http.StatusOK, "", data.(*am.AmUserInfo))

	// login as user and get user info
	d = data.(*am.AmUserInfo)
	cookieStr, _ = app.GenerateToken(userName, am.UserPermission, d.Pwd.TemporaryPwd, clientIP, stRestful.SignKey)
	cr.TestSetCookie(cookieStr)
	url = resourcePath + "/" + userName
	exeCommandCheckRes(t, cr.HTTPGetStr, url, http.StatusOK, "", data.(*am.AmUserInfo))
}

// Verify errors for the following secenarios:
// 1. Invalid password
// 2. Ilegal password data
// 3. Undefined user
// 4. Reset password for undefined user
func TestErrors(t *testing.T) {
	initAListOfUsers(t, usersName)

	url := listener + servicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleUserPwdCommand]), usersPath, defs.RootUserName, pwdPath)
	data, _ := json.Marshal(cr.UpdateSecret{OldPassword: "123", NewPassword: "123"})
	exeCommandCheckRes(t, cr.HTTPPatchStr, url, http.StatusBadRequest, "", cr.StringMessage{Str: cr.GetMessageStr})
	url = listener + servicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleUserPwdCommand]), usersPath, "undef user", pwdPath)
	exeCommandCheckRes(t, cr.HTTPPatchStr, url, http.StatusNotFound, string(data), cr.StringMessage{Str: cr.GetMessageStr})
	url = listener + servicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleUserPwdCommand]), usersPath, defs.RootUserName, pwdPath)
	exeCommandCheckRes(t, cr.HTTPPatchStr, url, http.StatusBadRequest, string(data), cr.StringMessage{Str: cr.GetMessageStr})

	// reset undefined user password
	url = listener + servicePath + fmt.Sprintf(cr.ConvertCommandToRequest(urlCommands[handleUserCommand]), usersPath, "undefined user")
	exeCommandCheckRes(t, cr.HTTPPatchStr, url, http.StatusNotFound, cr.GetMessageStr, cr.StringMessage{Str: cr.GetMessageStr})
}