// The OCRA package provides implementation of OATH services as defined by RFC 6287.
//
// The OCRA property:
//	Challengeâ€“response authentication: is a family of protocols
//	in which one party presents a question ("challenge") and
//	another party must provide a valid answer ("response") to be authenticated.
//	It may be used for mutual authentication
//	e.g. when a server needs to install a new version on a client.
//	In the case of the example, the client has to verify that
//	the server is the one it claims it is (otherwise a  malicious version may be downloaded)
//	and the server has to verify that it downloads the new version to the right client.
//
// The OATH Challenge-Response Algorithm (OCRA) is a generalization of
// HOTP with variable data inputs not solely based on an incremented
// counter and a secret key values.
//
// The definition of OCRA requires a cryptographic function, a key K and a set of DataInput parameters
//
// DataInput = {OCRASuite | 00 | C | Q | P | S | T} where:
//	- OCRASuite is a value representing the suite of operations to compute an OCRA response
//	-  00 is a byte value used as a separator
//	-  C is an unsigned 8-byte counter value processed high-order bit
//	-  Q (mandatory) is a 128-byte list of (concatenated) challenge question(s) generated by the parties
//	-  P is a hash (SHA-1, SHA-256 and SHA-512) value of PIN/password that is known to all parties
//	-  S is a UTF-8 encoded string that contains information about the current session
//	-  T is a number of time-steps (seconds, minutes, hours) since midnight UTC of January 1, 1970
//
// Note that all paramemters except for 'Q' are optional
//
// OCRA usage:
//	1. One-Way Challenge-Response
//	   A challenge-response is a security mechanism in which the verifier
//	   presents a question (challenge) to the prover, who must provide a
//	   valid answer (response) to be authenticated
//	2. Mutual Challenge-Response
//	   Mutual challenge-response is a variation of the one-way challenge-
//	   response mechanism where both the client and server mutually authenticate each other.
//	3. Plain Signature
//	   To use this algorithm in plain signature mode, the server will
//	   communicate a signature-challenge value to the client (signer).  The
//	   signature-challenge is either the data to be signed or is derived from
//	   the data to be signed using a hash function
//	4. Signature with Server Authentication
//	   This mode is a variation of the plain signature mode where the client
//	   can first authenticate the server before generating an electronic signature.
package ocra

import (
	"crypto/rand"
	"crypto/sha1"
	"crypto/sha256"
	"crypto/sha512"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"hash"
	"io"
	"io/ioutil"
	"math/big"
	"os"
	"reflect"
	"regexp"
	"strconv"
	"strings"

	stc "github.com/ibm-security-innovation/libsecurity-go/defs"
	logger "github.com/ibm-security-innovation/libsecurity-go/logger"
	"github.com/ibm-security-innovation/libsecurity-go/otp"
	ss "github.com/ibm-security-innovation/libsecurity-go/storage"
)

type appendSide int

const (
	ocraSuiteOcraProtocolIdx = 0
	ocraSuiteCryptoIdx       = 1
	ocraSuiteDataInputIdx    = 2
	ocraSuiteNumOfFields     = 3
	ocraSuiteProtocolIdx     = 0
	ocraSuiteHashLengthIdx   = 2

	ocraSuiteSplitToken                    = ":"
	ocraSuiteDigitSplitToken               = "-"
	ocraSuiteDataInputSplitToken           = "-"
	ocraSuiteDataInputCounterToken         = "c"
	ocraSuiteDataInputQuestionToken        = "q"
	ocraSuiteDataInputQuestionNumericToken = "n"
	ocraSuiteDataInputQuestionAlfabetToken = "a"
	ocraSuiteDataInputPasswordToken        = "p"
	ocraSuiteDataInputSessionToken         = "s"
	ocraSuiteDataInputTimeStampToken       = "t"
	dataInputAppendToken                   = 0
	ocraSuiteOcraProtocol                  = "ocra-1"
	ocraSuiteProtocolToken                 = "hotp"

	ocraSuiteDataInputQuestionTypeOptions = "nah"
	minOcraSuiteDataInputQuestionLength   = 4
	maxOcraSuiteDataInputQuestionLength   = 64

	ocraSuiteCounterLengthB   = 8
	ocraSuiteQuestionLengthB  = 128
	ocraSuiteTimeStampLengthB = 8

	minKeyLength = 6
	maxKeyLength = 512

	appendToLeft  appendSide = 0
	appendToRight appendSide = 1
)

var (
	ocraSuiteDataInputParseStruct    []parseData
	ocraSuiteDataInputValidTokensMap = make(map[byte]parseData)
	ocraValidOutputLength            = []int{0, 4, 5, 6, 7, 8, 9, 10}
	ocraValidOutputLengthMap         = make(map[int]int)
	dataInputCounterRegExp           = regexp.MustCompile("^c([a-zA-Z0-9]*-)")
	dataInputQuestionRegExp          = regexp.MustCompile(fmt.Sprintf("%s([%s])([0-9]*)", ocraSuiteDataInputQuestionToken, ocraSuiteDataInputQuestionTypeOptions))
	timeStampRegExp                  = regexp.MustCompile("(t[1-9][sm]|t[1-5][0-9][sm]|t[0-9]h|t[1-3][0-9]h|t4[0-8]h)")
	dataInputTokenFmt                = "%s(%s[a-zA-Z0-9]*)"
	dataInputPasswordTokenRegExp     = regexp.MustCompile(fmt.Sprintf(dataInputTokenFmt, ocraSuiteDataInputSplitToken, ocraSuiteDataInputPasswordToken))
	dataInputSessionTokenRegExp      = regexp.MustCompile(fmt.Sprintf(dataInputTokenFmt, ocraSuiteDataInputSplitToken, ocraSuiteDataInputSessionToken))
	dataInputTimeStampTokenRegExp    = regexp.MustCompile(fmt.Sprintf(dataInputTokenFmt, ocraSuiteDataInputSplitToken, ocraSuiteDataInputTimeStampToken))
)

type UserOcra struct {
	OcraSuite string
	Key       []byte
}

func (u UserOcra) String() string {
	return fmt.Sprintf("Key: %v, OCRA suite %v", u.Key, u.OcraSuite)
}

type parseData struct {
	token string
	cFunc func(string, string, parseData) (int, error)
	hFunc func(string, string, parseData) ([]byte, error)
	parse *regexp.Regexp
}

type inputData struct {
	name   string
	length int
}

func (d inputData) String() string {
	return fmt.Sprintf("Input data: name - '%v', length - %v", d.name, d.length)
}

type hashesData struct {
	name   string
	digest func() hash.Hash
	length int
}

var hashes = []hashesData{{"sha1", sha1.New, 0}, {"sha256", sha256.New, 0}, {"sha512", sha512.New, 0}}
var passwords = []inputData{{"psha1", 20}, {"psha256", 32}, {"psha512", 64}}

type Serializer struct{}

func init() {
	logger.Init(ioutil.Discard, ioutil.Discard, os.Stdout, os.Stderr)
	stc.Serializers[stc.OcraPropertyName] = &Serializer{}

	for _, val := range ocraValidOutputLength {
		ocraValidOutputLengthMap[val] = val
	}
	ocraSuiteDataInputParseStruct = []parseData{{ocraSuiteDataInputCounterToken, checkOcraDataInputCounterValidity, handleCounter, dataInputCounterRegExp},
		{ocraSuiteDataInputQuestionToken, checkOcraDataInputQuestionValidity, handleQuestion, dataInputQuestionRegExp},
		{ocraSuiteDataInputPasswordToken, checkOcraDataInputPasswordValidity, handlePassword, dataInputPasswordTokenRegExp},
		{ocraSuiteDataInputSessionToken, checkOcraDataInputSessionValidity, handleSession, dataInputSessionTokenRegExp},
		{ocraSuiteDataInputTimeStampToken, checkOcraDataInputTimeStampValidity, handleTimeStamp, dataInputTimeStampTokenRegExp}}
	for _, c := range ocraSuiteDataInputParseStruct {
		ocraSuiteDataInputValidTokensMap[c.token[0]] = c
	}
}

// Append a given string to a given length with the given character
// The append may be done to the left or to the right of the string
func appendStringToGivenLen(data []byte, l int, appendB byte, side appendSide) []byte {
	filler := []byte{}
	for i := len(data); i < l; i++ {
		filler = append(filler, appendB)
	}
	if side == appendToRight {
		return append(data, filler...)
	}
	return append(filler, data...)
}

// convert a given decimal string to hex byte array
func hexStrToHexByte(str string) ([]byte, error) {
	if len(str)%2 == 1 {
		str = "0" + str
	}
	return hex.DecodeString(str)
}

// Convert a given decimal string to hex byte array
func numericStrToByte(str string) ([]byte, error) {
	n := &big.Int{}
	_, ok := n.SetString(str, 10)
	if ok == false {
		return nil, fmt.Errorf("the string: %v is not a decimal string", str)
	}
	ret := fmt.Sprintf("%X", n)
	if len(ret)%2 == 1 {
		ret = ret + "0"
	}
	return hex.DecodeString(ret)
}

// If 'counter handling' is defined in the OCRA suite, extract the information from the
// given counter string, append it to the predefined length and return it as a byte array
func handleCounter(dataInput string, counter string, p parseData) ([]byte, error) {
	length, err := p.cFunc(dataInput, "", p)
	if err != nil {
		return nil, err
	} else if length == 0 {
		return nil, nil
	}

	c1, err := hexStrToHexByte(counter)
	if err != nil {
		return nil, err
	}
	c2 := appendStringToGivenLen(c1, ocraSuiteCounterLengthB, dataInputAppendToken, appendToLeft)
	logger.Info.Println("Counter calculations: in command:", dataInput, ", Original counter:", counter, ", convert to:", c1, "The new counter is:", c2, ", len:", len(c2))
	return c2, nil
}

// Extract the information from the given question string (using the OCRA suite question type: Alfabet, Hex or Numeric),
//  append it to the predefined length and return it as a byte array
func handleQuestion(dataInput string, question string, p parseData) ([]byte, error) {
	var q1, q2 []byte
	var err error

	format, _, err := parseQuestion(dataInput, p)
	if err != nil {
		return nil, err
	}
	if format == ocraSuiteDataInputQuestionNumericToken {
		q1, err = numericStrToByte(question)
		if err != nil {
			return nil, err
		}
	} else {
		q1 = []byte(question)
	}
	q2 = appendStringToGivenLen(q1, ocraSuiteQuestionLengthB, dataInputAppendToken, appendToRight)
	logger.Info.Println("Question calculations: in command:", dataInput, ", Original question:", question, "converted to:", []byte(q1), "The new question is:", q2, ", len:", len(q2))
	return q2, nil
}

// If 'password handling' is defined in the OCRA suite, extract and verify that the information from the
// given password string matches the predefined password options,
// append it to the predefined length and return it as byte array
func handlePassword(dataInput string, password string, p parseData) ([]byte, error) {
	var p2 []byte

	pass, _, err := extractDataInputToken(dataInput, p)
	if err != nil {
		return nil, fmt.Errorf("OCRA suite %v: password error: %v", dataInput, err)
	}

	if len(pass) == 0 {
		return p2, nil
	}
	for _, p := range passwords {
		if pass == p.name {
			p1, err := hexStrToHexByte(password)
			if err != nil {
				return nil, err
			}
			p2 = appendStringToGivenLen(p1, p.length, dataInputAppendToken, appendToLeft)[0:p.length]
			logger.Info.Println("Password calculations: in command:", dataInput, ", match:", p.name, ", original password:", password, len(password), ", The new password is:", []byte(p2), ", len:", len(p2))
		}
	}
	return p2, nil
}

// If 'session handling' is defined in the OCRA suite, extract the information from the
// given session string, append it to the extracted length and return it as a byte array
func handleSession(dataInput string, session string, p parseData) ([]byte, error) {
	var s2 []byte

	ses, _, err := extractDataInputToken(dataInput, p)
	if err != nil {
		return nil, fmt.Errorf("OCRA suite %v: session error: %v", dataInput, err)
	}
	if len(ses) == 0 {
		return nil, nil
	}
	length, err := p.cFunc(dataInput, session, p)
	if err != nil || length <= 0 {
		return nil, err
	}
	s1, err := hexStrToHexByte(session)
	if err != nil {
		return nil, err
	}
	s2 = appendStringToGivenLen(s1, length, dataInputAppendToken, appendToLeft)[0:length]
	logger.Info.Println("Session calculations: in command:", dataInput, ", session length:", length, ", The original session:", session, "Convert to:", s1, ", The new session is:", s2, ", len:", len(s2))
	return s2, nil
}

// If 'timeStamp handling' is defined in the OCRA suite, extract the information from the
// given timeStamp string, append it to the predefined length and return it as a byte array
func handleTimeStamp(dataInput string, timeStamp string, p parseData) ([]byte, error) {
	var t2 []byte

	t, _, err := extractDataInputToken(dataInput, p)
	if err != nil {
		return nil, fmt.Errorf("OCRA suite %v: time stamp error: %v", dataInput, err)
	}
	if len(t) == 0 {
		return t2, nil
	}
	t1, err := hexStrToHexByte(timeStamp)
	if err != nil {
		return nil, err
	}
	t2 = appendStringToGivenLen(t1, ocraSuiteTimeStampLengthB, dataInputAppendToken, appendToLeft)
	logger.Info.Println("Timestamp calculations: in command:", dataInput, ", The original timeSTamp:",
		timeStamp, ", The new timeStamp is:", t2, ", len:", len(t2))
	return t2, nil
}

// Generate the data input to be used by the OCRA hash function.
// This function uses the OCRA suite as guidence for the relevant part of the OCRA suite input strings
func getDataInput(dataInput string, counter, question, password, session, timeStamp string) ([]byte, error) {
	ret := []byte{}
	val := []string{counter, question, password, session, timeStamp}

	for i, c := range ocraSuiteDataInputParseStruct {
		data, err := c.hFunc(dataInput, val[i], c)
		if err != nil {
			return nil, err
		}
		ret = append(ret, data...)
	}
	return ret, nil
}

// Parse the OCRA suite string, the OCRA suite format:
// An OCRASuite value is a text string that captures one mode of operation for OCRA,
//   <Algorithm>:<CryptoFunction>:<DataInput>
func parseOcraString(ocraSuite string) ([]string, error) {
	data := strings.Split(ocraSuite, ocraSuiteSplitToken)
	if len(data) != ocraSuiteNumOfFields {
		return nil, fmt.Errorf("OcraSuite string '%v' is invalid, it must contains %v fields, seperated by %v",
			ocraSuite, ocraSuiteNumOfFields, ocraSuiteSplitToken)
	}
	return data, nil
}

// This function extracts the OCRA suite crypto function:
//  The format of the crypto function is: "HOTP-H-t:".
//    An HMAC function is used with the hash function H, when
//		the options for H are: SHA1, SHA256 and SHA512,
//		and the dynamic truncation of t-digit value (t=0 means that no truncation is performed)
func parseCryptoString(crypto string) (hashesData, error) {
	for _, h := range hashes {
		if strings.Index(crypto, h.name) != -1 {
			data := strings.Split(crypto, ocraSuiteDigitSplitToken)
			if data[ocraSuiteProtocolIdx] != ocraSuiteProtocolToken {
				return hashesData{}, fmt.Errorf("the protocol in OcraSuite crypto string %v is illegal, the format must be of the form: HOTP-H-t", crypto)
			}
			val, err := strconv.Atoi(data[ocraSuiteHashLengthIdx])
			_, exists := ocraValidOutputLengthMap[val]
			if err != nil || exists == false {
				return hashesData{}, fmt.Errorf("number of digits to present in OcraSuite crypto string: %v is illegal, the format must beof the form: HOTP-H-t and t must be a number from %v", crypto, ocraValidOutputLength)
			}
			if val > 0 {
				h.length = val
			} else {
				h.length = maxKeyLength
			}
			return h, nil
		}
	}
	return hashesData{}, fmt.Errorf("illegal ocraSuite crypto string: %v. The Crypto function must be of the form: %v", crypto, hashes)
}

// Return the extracted data input token (if exists) to be handled by the relevant function
func extractDataInputToken(dataInput string, p parseData) (string, []string, error) {
	param := ocraSuiteDataInputSplitToken + p.token
	length := strings.Count(dataInput, param)
	if strings.HasPrefix(dataInput, p.token) {
		length = length + 1
	}
	if length > 1 {
		return "", nil, fmt.Errorf("data input '%v' format is illegal: it contains parameter '%v', which is valid, more than once, %v", dataInput, param, length)
	}
	vec := p.parse.FindStringSubmatch(dataInput)

	if len(vec) > 0 {
		return vec[1], vec, nil
	}
	return "", nil, nil
}

// Verify that the password format is valid. A Valid format should have the form PH where H must be one of SHA1, SHA256 or SHA512
func checkOcraDataInputPasswordValidity(dataInput, _ string, p parseData) (int, error) {
	password, _, err := extractDataInputToken(dataInput, p)
	if err != nil {
		return -1, fmt.Errorf("OCRA suite %v: password error: %v", dataInput, err)
	}

	if len(password) == 0 {
		return 0, nil
	}
	for _, p := range passwords {
		if password == p.name {
			return len(password), nil
		}
	}
	return -1, fmt.Errorf("OCRA suite %v password: %v format is illegal, it should be of the form PH where H must be one of %v", dataInput, password, passwords)
}

// Verify that the counter format is valid. A Valid format should be the counter as the prefix of the dat ainput without any extra characters
func checkOcraDataInputCounterValidity(dataInput, _ string, p parseData) (int, error) {
	counter, _, err := extractDataInputToken(dataInput, p)
	if err != nil {
		return -1, fmt.Errorf("OCRA suite %v: counter error: %v", dataInput, err)
	}

	if len(counter) == 0 {
		return 0, nil
	} else if len(counter) == 1 {
		return len(counter), nil
	}
	return -1, fmt.Errorf("OCRA suite %v counter: %v format must be %v%v", dataInput, counter, ocraSuiteDataInputCounterToken, ocraSuiteDataInputSplitToken)
}

// Verify that the time stamp format is valid
// A valid format must have the form T [1-59]S | [1-59]M | [0-48]H
func checkOcraDataInputTimeStampValidity(dataInput, _ string, p parseData) (int, error) {
	timeStamp, _, err := extractDataInputToken(dataInput, p)
	if err != nil {
		return -1, fmt.Errorf("OCRA suite %v: time stamp error: %v", dataInput, err)
	}
	if len(timeStamp) == 0 {
		return -1, nil
	}

	data := string(timeStampRegExp.Find([]byte(timeStamp)))
	logger.Info.Println("data input", dataInput, "time stamp", timeStamp, "data", data, "len:", len(data), len(timeStamp))
	if len(data) != len(timeStamp) {
		return 0, fmt.Errorf("OCRA suite %v TimeStamp: %v format must be of the form TV where V must be one of [1-59]S or [1-59]M or [0-48]H", dataInput, timeStamp)
	}
	return -1, nil
}

// Verify that the session format is valid, Valid format must have the form Snnn where n is numeric value
func checkOcraDataInputSessionValidity(dataInput, _ string, p parseData) (int, error) {
	session, _, err := extractDataInputToken(dataInput, p)
	if err != nil {
		return -1, fmt.Errorf("OCRA suite %v: session error: %v", dataInput, err)
	}
	if len(session) == 0 {
		return 0, nil
	}
	if len(session) < 4 {
		return 0, fmt.Errorf("OCRA suite data input %v, session: %v must be in the format Snnn", dataInput, session)
	}
	return strconv.Atoi(session[1:4])
}

// Question format is: Q[AHN]nn, where A is for an Alfanumeric string, H is for a Hex string and N is for a Numeric string
// nn is the minimal question length and it must be between 04-64
func parseQuestion(dataInput string, p parseData) (string, int, error) {
	_, vec, err := extractDataInputToken(dataInput, p)

	// Verify that the question length is valid
	if len(vec) < 3 {
		return "", -1, fmt.Errorf("OCRA suite %v question format length must be 4: QFnn, vec %v", dataInput, vec)
	}

	format := vec[1]

	length, err := strconv.Atoi(vec[2])
	if err != nil || length < minOcraSuiteDataInputQuestionLength || length > maxOcraSuiteDataInputQuestionLength {
		return "", -1, fmt.Errorf("OCRA suite %v question format must be of the form QFxx where xx range is %v-%v",
			dataInput, minOcraSuiteDataInputQuestionLength, maxOcraSuiteDataInputQuestionLength)
	}
	logger.Info.Println("data input:", dataInput, "format:", format, "length:", length)
	return format, length, nil
}

// Verify that the question format is valid. A valid format must have the form:
// Q[AHN]nn where A is for an Alfanumeric string, H is for a Hex string and N is for a Numeric string
// nn is the minimal question length and it must be between 04-64
// The length of the given question must be at least the extracted nn parameter
func checkOcraDataInputQuestionValidity(dataInput, question string, p parseData) (int, error) {
	_, length, err := parseQuestion(dataInput, p)
	if err != nil {
		return -1, err
	}
	if len(question) < length {
		return -1, fmt.Errorf("OCRA suite %v question '%v' length is %v but should be at least %v", dataInput, question, len(question), length)
	}
	return length, nil
}

// Verify that the data input string format is valid
// Valid format must be of the form [C] | QFxx | [PH | Snnn | TG]
// The verification is done by calling each of the relevant check functions
func checkOcraDataInputValidity(dataInput string, question string) error {
	vec := strings.Split(dataInput, ocraSuiteDataInputSplitToken)
	exist := false
	for i, token := range vec {
		if len(token) > 0 {
			_, exist = ocraSuiteDataInputValidTokensMap[token[0]]
		}
		if len(token) == 0 || exist == false ||
			(strings.HasPrefix(token, ocraSuiteDataInputCounterToken) && (i > 0 || len(token) > 1)) {
			return fmt.Errorf("OCRA suite data Input '%v' includes an undefined token '%v'", dataInput, token)
		}
	}

	for _, c := range ocraSuiteDataInputParseStruct {
		_, err := c.cFunc(dataInput, question, c)
		if err != nil {
			return err
		}
	}
	return nil
}

func checkOcraProtocolValidity(ocraSuite string, protocol string) error {
	if strings.HasPrefix(protocol, ocraSuiteOcraProtocol) == false {
		return fmt.Errorf("OCRA suite %v must start with %v", ocraSuite, ocraSuiteOcraProtocol)
	}
	return nil
}

// Verify that the key is hex decoded and its length is in the defined range
func isOcraKeyValid(key []byte) error {
	_, err := hex.DecodeString(string(key))
	if err != nil {
		return fmt.Errorf("key '%v' is illegal, error: %v", key, err)
	}
	if len(key) < minKeyLength || len(key) > maxKeyLength {
		return fmt.Errorf("Key length is (%v) is outside the allowed range %v-%v", len(key), minKeyLength, maxKeyLength)
	}
	return nil
}

// Check that the OCRA suite is valid by checking each of its 3 parts: <Algorithm>:<CryptoFunction>:<DataInput>
func isOcraSuiteValid(ocraSuite string) error {
	data, err := parseOcraString(ocraSuite)
	if err != nil {
		return err
	}
	err = checkOcraProtocolValidity(ocraSuite, strings.ToLower(data[ocraSuiteOcraProtocolIdx]))
	if err != nil {
		return err
	}
	_, err = parseCryptoString(strings.ToLower(data[ocraSuiteCryptoIdx]))
	return err
}

// Check that the OCRA suite, its question and its key are valid by checking each of its 3 parts: <Algorithm>:<CryptoFunction>:<DataInput>
func isOcraDataValid(ocraSuite, question string, key string) error {
	err := isOcraSuiteValid(ocraSuite)
	if err != nil {
		return err
	}
	err = isOcraKeyValid([]byte(key))
	if err != nil {
		return err
	}
	data, _ := parseOcraString(ocraSuite)
	return checkOcraDataInputValidity(strings.ToLower(data[ocraSuiteDataInputIdx]), question)
}

// An OCRASuite value is represented as follows: <Algorithm>:<CryptoFunction>:<DataInput>
// Algorithm must be OCRA-v1
// CryptoFunction = HOTP-H-t: HMAC function with the hash function H, and the dynamic truncation
//       as described in [RFC4226] to extract a t-digit value. t=0 means that no truncation is performed and the full HMAC value is used for authentication purposes.
//       The options for H are: SHA1, SHA256, SHA512
//       The options for t are: 0, 4-10
// DataInput:
//   [C] | QFxx | [PH | Snnn | TG] : Challenge-Response computation
//          Format (F): one of A (alphanumeric), N (numeric), H (hexadecimal), followed by a length with a value between 04-64
//          S is further qualified by the length of the session data in bytes.
//            The client and server could agree to any length but the typical values are: Length (nnn) - 064, 128, 256, and 512.
//          T for timestamps (since epoch time), G can be specified in any of the time units - seconds, minutes, or hours: [1-59]S, [1-59]M, [0-48]H
func getOcraSetup(ocraSuite string, counter, question, password, session, timeStamp string) (hashesData, []byte, error) {
	data, err := parseOcraString(ocraSuite)
	if err != nil {
		return hashesData{}, nil, err
	}
	cryptoData, err := parseCryptoString(strings.ToLower(data[ocraSuiteCryptoIdx]))
	if err != nil {
		return hashesData{}, nil, err
	}
	msg, err := getDataInput(strings.ToLower(data[ocraSuiteDataInputIdx]), counter, question, password, session, timeStamp)
	return cryptoData, msg, err
}

func buildOtpData(ocraSuite, key string, msg []byte) ([]byte, []byte, error) {
	ret := []byte(ocraSuite)
	seperator := []byte{0}
	hmacText := append(ret, seperator...)
	hmacText = append(hmacText, msg...)

	hmacKey, err := hex.DecodeString(key)
	if err != nil {
		e := fmt.Errorf("can't convert key %v to hex byte array, error: %v", key, err)
		return nil, nil, e
	}
	return hmacKey, hmacText, nil
}

// Generates an OCRA HOTP value for the given minimal parameters: OCRASuite, key and question
func GenerateOCRA(key string) (string, string, error) {
	question := make([]byte, 8)
	io.ReadFull(rand.Reader, question)
	otp, err := GenerateOCRAAdvance("OCRA-1:HOTP-SHA1-6:QA08", key, "", string(question), "", "", "")
	return otp, string(question), err
}

// Generates an OCRA HOTP value for the given set of parameters as defined by RFC 6287:
// OCRA suite: <Algorithm>:<CryptoFunction>:<DataInput>
// key: the shared secret, HEX encoded
// counter:   the counter that changes per use basis, HEX encoded
// question   the challenge question, HEX encoded. This is a mandatory parameter
// password   a password that can be used, HEX encoded
// sessionInformation Static information that identifies the current session, Hex encoded
// timeStamp    a value that reflects a time in Minutes or Hours
// IC6 - All the communications SHOULD take place over a secure channel, e.g., SSL/TLS [RFC5246], IPsec connections.
func GenerateOCRAAdvance(ocraSuite, key, counter, question, password, session, timeStamp string) (string, error) {
	err := isOcraDataValid(ocraSuite, question, key)
	if err != nil {
		return "", err
	}

	cryptoData, msg, err := getOcraSetup(ocraSuite, counter, question, password, session, timeStamp)
	if err != nil {
		return "", err
	}

	hmacKey, hmacText, err := buildOtpData(ocraSuite, key, msg)
	if err != nil {
		return "", fmt.Errorf("can't create key or text for %v, with key %v and text %v, error: %v", ocraSuite, key, msg, err)
	}

	otp, err := otp.NewOtpAdvance([]byte(hmacKey), cryptoData.length, cryptoData.digest)
	if err != nil {
		return "", fmt.Errorf("can't create new HOTP for key %v (%v), error: %v", key, hmacKey, err)
	}
	code := otp.GenerateHmac(hmacText)

	logger.Info.Println("OTP:", code, "secret:", hmacKey, "digest:", cryptoData.name, "\n\ttext", hmacText, "len:", len(hmacText))
	return code, nil
}

// Generate a new userOcra for a given key and OCRA suite
func NewOcraUser(key []byte, ocraSuite string) (*UserOcra, error) {
	err := isOcraKeyValid(key)
	if err != nil {
		return nil, err
	}
	err = isOcraSuiteValid(ocraSuite)
	if err != nil {
		return nil, err
	}
	return &UserOcra{ocraSuite, key}, nil
}

// Update the user's secret key
func (u *UserOcra) UpdateOcraKey(key []byte) error {
	err := isOcraKeyValid(key)
	if err != nil {
		return err
	}
	u.Key = key
	return nil
}

// Update the user's secret key
func (u *UserOcra) UpdateOcraSuite(ocraSuite string) error {
	err := isOcraSuiteValid(ocraSuite)
	if err == nil {
		u.OcraSuite = ocraSuite
	}
	return err
}

func (s Serializer) PrintProperties(data interface{}) string {
	d, ok := data.(*UserOcra)
	if ok == false {
		return "can't print the OCRA property it's of a wrong type"
	}
	return d.String()
}

func (s Serializer) IsEqualProperties(da1 interface{}, da2 interface{}) bool {
	d1, ok1 := da1.(*UserOcra)
	d2, ok2 := da2.(*UserOcra)
	if ok1 == false || ok2 == false {
		return false
	}
	return reflect.DeepEqual(d1, d2)
}

// Store User data info to the secure_storage
func (s Serializer) AddToStorage(prefix string, data interface{}, storage *ss.SecureStorage) error {
	d, ok := data.(*UserOcra)
	if ok == false {
		return fmt.Errorf("can't store the OCRA property: its not in the right type")
	}
	if storage == nil {
		return fmt.Errorf("can't add OCRA property to storage, storage is nil")
	}
	value, _ := json.Marshal(d)
	err := storage.AddItem(prefix, string(value))
	if err != nil {
		return err
	}
	return nil
}

// Read the user information from disk (in JSON format)
func (s Serializer) ReadFromStorage(key string, storage *ss.SecureStorage) (interface{}, error) {
	var user UserOcra

	if storage == nil {
		return nil, fmt.Errorf("can't read AM property from storage, storage is nil")
	}
	value, exist := storage.Data[key]
	if !exist {
		return nil, fmt.Errorf("key '%v' was not found in storage", key)
	}
	err := json.Unmarshal([]byte(value), &user)
	if err != nil {
		return nil, err
	}
	return &user, nil
}
